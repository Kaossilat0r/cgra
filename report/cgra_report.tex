\documentclass[oneside,11pt,accentcolor=tud2b, nochapname]{tudexercise}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}

\usepackage{ngerman} % umlaute...
\usepackage{german} % umlaute...

\usepackage{hyperref}
\usepackage{color}
\usepackage{listings}
\usepackage{graphicx}

% Hurenkinder und Schusterjungen verhindern
\clubpenalty10000
\widowpenalty10000
\displaywidowpenalty=10000

% remove space between items 
\usepackage{enumitem}
	\setenumerate{noitemsep}
	\setitemize{noitemsep}
	\setdescription{noitemsep}

\title{Rechnersysteme 2}
\subtitle{CGRA Versuch\\
Wintersemester 2013/2014}

\subsubtitle{\\
Sebastian Fahnenschreiber (\href{mailto:sebastian.fahnenschreiber@stud.tu-darmstadt.de}{sebastian.fahnenschreiber@stud.tu-darmstadt.de})\\
Roman Neß (\href{mailto:roman.ness@stud.tu-darmstadt.de}{roman.ness@stud.tu-darmstadt.de})}

\selectlanguage{german}


\geometry{left=2.25cm,right=1.66cm,top=2.cm,bottom=2.25cm,includeheadfoot,heightrounded}
\begin{document}

\maketitle

\section*{Implementierte Funktionalität}

\section*{Herangehensweise}
Wir handelten frei nach dem Motto: "`Make It Work, Make It Right, Make It Fast"':

\begin{itemize}
	\item erste Version in "`intuitivem"' C-Code
	\item Test der korrekten Funktionsweise bei nativer Kompilierung (mittels printf)
	\item Benutzung der Toolchain ohne Auslagerung von Berechnungen auf CGRA testen
	\item \textbf{dresc\_params\_v3} auf verwendete Schleifen anpassen und unoptimierte Performance messen
	\item Optimierungs-Zyklus beginnen (Ändern, Compilieren, Auswerten, Repeat)
\end{itemize}

\section*{Optimierung}
Wir entschieden uns zunächst den Code für das Ziel "`performance-max"' hin zu optimieren.
Hauptgrund hierfür war das klar verständliche Kriterium von möglichst wenigen Taktzyklen um jeden Preis.\\
\\
Wir verwenden die "`6x6"' Instanz, weil davon auszugehen ist, dass mehr FUs mehr parallele Arbeit in kürzerer Zeit bewältigen können.
Da ein Leerlauf einzelner FUs das Ergebnis nicht negativ beeinflussen kann, sahen wir keinen Grund die kleineren Instanzen zu testen.\\
\\
Wir gehen davon aus, dass sich die Performance noch weiter steigern lassen könnte, wenn ein noch größeres Array verwendet wird.
Besonders müsste das für jede Schleifen gelten, in denen der Compiler wegen mangelnder Ressourcen ein erhöhtes Initiation Interval erzwingt.
Allerdings konnten wir nicht herausfinden wie sich ein eigenes Array automatisch erzeugen lässt und ein händisches Erstellen schien den Rahmen dieses Versuchs klar zu sprengen.\\
\\
Konkret wurden die folgenden Optimierungstechniken angewandt:
\begin{description}	
	\item[Kein Loop Nesting] \hfill \\
	Alle geschachtelten Schleifen wurden aufgelöst um den Kontrollfluss auf dem CGRA zu vereinfachen und Overhead durch die Schleifen zu verhindern.\\
	
	\item[Minimierung der Speicherzugriffe] \hfill \\
	Da Speicherzugriffe die teuersten Operation sind, wurde die Anzahl der Speicherzugriffe auf das absolute Minimum reduziert.
	Das heißt, jedes Array-Element wird in einer Transformation genau einmal gelesen und genau einmal geschrieben.
	Dies lässt sich auch in der Ausgabe auf der Konsole nachvollziehen (576 Elemente * 4 Transformationen = 2304 [+1 Zugriff für Basisadresse]).\\
	
	\item[Vorausberechnung von Konstanten] \hfill \\
	Alle Konstanten die schon zur Compile-Zeit vorberechnet werden können, werden als Makros definiert. 
	Darunter fallen z.B. Startindizes der Matrix oder Offsets zwischen Elementen.\\
	
	\item[Method Inlining] \hfill \\
	Um Methodenaufrufe auf dem CGRA zu verhindern und den Code gleichzeitig lesbar zu halten, werden Unterfunktionen in optimierten Schleifen als inline definiert.
	Da der Compiler bei Tests den "`inline"' Modifier mitunter ignorierte, erzwingen wir  Inlining per Compiler Attribut \texttt{\_\_attribute\_\_((always\_inline))}.\\
	
	\item[Intrinsics] \hfill \\
	Zur Berechnung des Durchschnitts verwenden wir ein eingebautes Intrinsic der Architektur (\texttt{intr12\_gp\_\_avg}).\\
	
	\item[Optimierung der Ausgabefunktion] \hfill \\
	Da zunächst Kommuniziert wurde, dass die Ausgabe der Matrix Teil der Performance Messung sein muss, optimierten wir auch diese.
	Es zeigte sich, dass bei der Ausgabefunktion im Vergleich zur Berechnung ein viel größeres Optimierungspotential besteht.\\
	Nach der Optimierung mittels massivem loop-unrolling benötigte die Ausgabe der 24x24 Matrix bei unserer Lösung etwa 800 Taktzyklen.
	Aufgrund der Komplexität des entstanden Codes fielen wir wieder auf eine unoptimierte Version zurück, als bekannt wurde, dass die Ausgabe nicht Teil der Messung ist.
	
\end{description}


\section*{Herausforderungen}

Die Benutzung der Toolchain war nicht frei von Hindernissen.
Zu Beginn des Versuchs war die bereitgestellte VM nicht in einem Zustand, in dem wir sie für unseren Workflow gebrauchen konnten.
So musste z.B. ssh eingerichtet werden und die Befehle zur Verwendung der Toolchain aus einer Geany Konfigurationsdatei extrahiert werden.\\
\\
Weiterhin hat das Shellscript zur Ausgabe bei uns zu Beginn nicht funktioniert. 
Wir haben es deswegen aus dem /usr Verzeichnis in den Workspace kopiert und repariert.
Die Berechnung der Ergebnisse blieb dabei unangetastet.\\
\\
Auch der Komfort während des Entwickelns war nicht wirklich gut.
Insbesondere fielen die Geschwindigkeit des Compiliervorgangs und die Fehleranfälligkeit bei Anpassung der Zeilennummern in der Datei "`dresc\_params\_v3"' negativ auf.\\
\\
Alles in allem war das Projekt sehr gut machbar, jedoch konnte das Optimierungspotential nicht vollständig ausgenutzt werden, da die XML-Konfiguration der Instanzen undurchsichtig war.
Ein Tool zur Erstellung von eigenen Instanzen (oder auch nur eine Visualisierung einer bestehenden Instanz) hätte uns hier sehr geholfen.
Leider konnte das Manual aufgrund des Aufbaus nicht als Nachschlagewerk helfen.
Abschließend ist zu sagen, dass wir wohl an einem Punkt angelangt sind, an dem weitere Optimierungen zwar möglich aber vom Zeitaufwand her nicht mehr vertretbar sind.



\end{document}
